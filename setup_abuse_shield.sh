#!/bin/bash

# ============================================================
# Nginx Abuse Shield - Interactive Installer
# ============================================================

set -e

# --- Configuration Constants ---
INSTALL_DIR="/usr/local/bin/nginx-abuse-shield"
CONFIG_DIR="/etc/nginx/abuse_shield"
CRON_FILE="/etc/cron.d/nginx_abuse_shield"

# Colors for output
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo -e "${GREEN}Starting Nginx Abuse Shield Installer...${NC}"

# 1. Check Root
if [[ $EUID -ne 0 ]]; then
   echo -e "${RED}This script must be run as root.${NC}"
   exit 1
fi

# 2. Log File Configuration
echo "------------------------------------------------"
echo "Log File Configuration"
echo -e "${YELLOW}IMPORTANT: This tool requires a log format starting with \$msec (Epoch Timestamp).${NC}"
echo "Standard 'combined' logs will NOT work efficiently."
echo ""

read -p "Enter full path to your access log [default: /var/log/nginx/concise.log]: " LOG_PATH
LOG_PATH=${LOG_PATH:-/var/log/nginx/concise.log}

# Check if log exists
if [ ! -f "$LOG_PATH" ]; then
    echo -e "${YELLOW}Warning: Log file $LOG_PATH not found.${NC}"
    echo "We will proceed, but ensure you configure Nginx to write to this location."
else
    # Check Log Format (First column must be a number/timestamp)
    # We check the last line to ensure we aren't reading an empty file header
    LAST_LINE=$(tail -n 1 "$LOG_PATH")
    FIRST_PART=$(echo "$LAST_LINE" | awk '{print $1}')
    
    # Simple regex check for timestamp format (e.g. 1766275226.705)
    if [[ ! "$FIRST_PART" =~ ^[0-9]+\.[0-9]+$ ]] && [[ ! "$FIRST_PART" =~ ^[0-9]+$ ]]; then
        echo -e "${RED}ERROR: The log file does not appear to start with a timestamp (\$msec).${NC}"
        echo "Found: '$FIRST_PART' in the last line."
        echo "Please configure your Nginx log_format as follows:"
        echo "   log_format concise '\$msec \$remote_addr \$is_bot \$host \$status';"
        echo ""
        read -p "Do you want to abort and fix this? (y/n) " -n 1 -r
        echo
        if [[ $REPLY =~ ^[Yy]$ ]]; then exit 1; fi
    else
        echo -e "${GREEN}Log format check passed.${NC}"
    fi
fi

# 3. Time Window Configuration
echo ""
read -p "Enter detection time window in seconds [default: 3000]: " TIME_WINDOW
TIME_WINDOW=${TIME_WINDOW:-3000}

# 4. Create Directories
echo "------------------------------------------------"
echo "Installing files..."
mkdir -p "$INSTALL_DIR"
mkdir -p "$CONFIG_DIR"

# 5. Generate range_checker.sh
cat <<EOF > "$INSTALL_DIR/range_checker.sh"
#!/bin/bash
# Generated by Abuse Shield Installer
# Usage: ./range_checker.sh <time_window_seconds> <ip_parts>

set -euo pipefail

time_window=\${1:-$TIME_WINDOW}
ip_parts=\${2:-2}

# Known good ranges to completely ignore (Google, Bing, etc.)
skip_ranges=(
    "52.167" "57.141" "66.249" "40.77" "157.55" "207.46" "13.66"
)

skip_list=\$(printf "%s|" "\${skip_ranges[@]}"); skip_list=\${skip_list%|}
now=\$(date +%s)
log_files="$LOG_PATH $LOG_PATH.1"

# Check if files exist to avoid awk errors
valid_logs=""
for f in \$log_files; do
    [ -f "\$f" ] && valid_logs="\$valid_logs \$f"
done

if [ -z "\$valid_logs" ]; then
    exit 0
fi

# AWK assumption: \$1=timestamp, \$2=IP, \$5=status
awk -v now="\$now" -v skip="\$skip_list" -v window="\$time_window" -v parts="\$ip_parts" '
    \$1 >= now - window && \$5 != 429 {
        split(\$2, a, ".")
        key = a[1]
        for (i = 2; i <= parts && i <= 4; i++) key = key "." a[i]
        if (key !~ "^(" skip ")\$") count[key]++
    }
    END {
        for (k in count) print k, count[k]
    }
' \$valid_logs | sort -k2 -nr
EOF

chmod +x "$INSTALL_DIR/range_checker.sh"

# 6. Generate save_offending_ips.sh
cat <<EOF > "$INSTALL_DIR/save_offending_ips.sh"
#!/bin/bash
# Generated by Abuse Shield Installer

set -euo pipefail

TIME_WINDOW=\${1:-$TIME_WINDOW}

# Thresholds
THRESH_IP=\$(( TIME_WINDOW / 2 ))          # e.g. 1500 reqs
THRESH_3PART=\$(( (2 * TIME_WINDOW) / 3 )) # e.g. 2000 reqs
THRESH_2PART=\$(( (5 * TIME_WINDOW) / 6 )) # e.g. 2500 reqs

LOG_FILES="$LOG_PATH $LOG_PATH.1"
GEN_SCRIPT="$INSTALL_DIR/range_checker.sh"
OUTPUT_FILE="$CONFIG_DIR/offending_ips.conf"
LOG_OUTPUT="/var/log/abuse-shield.log"

TMP=\$(mktemp)
trap 'rm -f "\$TMP" "\$TMP".*' EXIT

touch "\$OUTPUT_FILE"

timestamp() {
    echo "[ \$(date '+%Y-%m-%d %H:%M:%S') ] \$*"
}

# Redirect output to log file if not interactive
if [ -t 1 ]; then
    : # Running in terminal
else
    exec >> "\$LOG_OUTPUT" 2>&1
fi

timestamp "Running analysis... Window: \${TIME_WINDOW}s"

# Check log existence
if [ ! -f "$LOG_PATH" ]; then
    timestamp "ERROR: Main log file $LOG_PATH does not exist."
    exit 1
fi

# 1. Find candidate 2-part prefixes (Broad Sweep)
\$GEN_SCRIPT "\$TIME_WINDOW" 2 \
    | awk -v thr="\$(( THRESH_IP / 4 ))" '\$2 >= thr {print \$1}' > "\$TMP"

if [[ ! -s "\$TMP" ]]; then
    exit 0
fi

added_any=false
valid_logs=""
for f in \$LOG_FILES; do [ -f "\$f" ] && valid_logs="\$valid_logs \$f"; done

while IFS= read -r prefix; do
    # 1. Extract IPs for this prefix
    # Assumes \$1=time, \$2=ip, \$5=status
    awk -v now=\$(date +%s) -v pre="\$prefix" -v TW="\$TIME_WINDOW" '
        \$1 >= now-TW && \$5 != 429 && \$2 ~ ("^" pre "\\\\.") {print \$2}
    ' \$valid_logs > "\$TMP.ips"

    [[ -s "\$TMP.ips" ]] || continue

    # 2. STATS PREPARATION
    sort "\$TMP.ips" | uniq -c | sort -n > "\$TMP.counts"

    num_unique_ips=\$(wc -l < "\$TMP.counts")
    mid_idx=\$(( (num_unique_ips + 1) / 2 ))
    median=\$(sed -n "\${mid_idx}p" "\$TMP.counts" | awk '{print \$1}')
    median=\${median:-1}

    # 3. DECISION LOGIC
    awk -v median="$median" \
        -v t_ip="$THRESH_IP" \
        -v t_3="$THRESH_3PART" \
        -v t_2="$THRESH_2PART" \
        -v pre="$prefix" '
    BEGIN { OFS="=" }
    {
        count = $1
        ip = $2

        # --- NEW: Track RAW totals (Before Noise Filter) ---
        # This catches "Low and Slow" attacks where 100 IPs do 5 reqs each
        split(ip, a, ".")
        s_key = a[1]"."a[2]"."a[3]
        
        raw_subnet_counts[s_key] += count
        raw_prefix_total += count
        # ---------------------------------------------------

        # A. NOISE FILTER (Existing Logic)
        cutoff = median / 2
        if (cutoff < 10) cutoff = 10

        if (count >= cutoff) {
            # This IP is statistically significant ("Abusive")
            # We still track this to detect "A few bad apples" in a subnet
            subnet_counts[s_key] += count
            total_abusive_reqs += count

            if (count >= t_ip) {
                bad_ips[ip] = count
            }
        }
    }
    END {
        # B. DECISION LOGIC
        
        # Define Hard Limits (if aggregate requests exceed this, rate-limit range anyway)
        hard_t_3 = t_3 * 2
        hard_t_2 = t_2 * 2

        # 1. Check specific 3-part ranges (/24)
        for (s_key in raw_subnet_counts) {
            
            # Condition 1: High "Qualified" Abuse (Existing) OR
            # Condition 2: High "Raw" Volume (New - catches distributed attacks)
            if (subnet_counts[s_key] >= t_3 || raw_subnet_counts[s_key] >= hard_t_3) {
                
                # Use the higher of the two counts for the log message
                final_count = (raw_subnet_counts[s_key] > subnet_counts[s_key]) ? raw_subnet_counts[s_key] : subnet_counts[s_key]
                
                print "BAN_3PART", s_key, final_count
                
                # Remove this traffic from the totals so we dont double-ban the /16
                total_abusive_reqs -= subnet_counts[s_key]
                raw_prefix_total   -= raw_subnet_counts[s_key]
            }
        }

        # 2. Check whole /16
        # Same logic: Check qualified abuse OR raw saturation
        if (total_abusive_reqs >= t_2 || raw_prefix_total >= hard_t_2) {
             # Use max count
             final_count = (raw_prefix_total > total_abusive_reqs) ? raw_prefix_total : total_abusive_reqs
             print "BAN_2PART", pre, final_count
        } else {
            # 3. Check individual IPs
            for (ip in bad_ips) {
                split(ip, a, ".")
                s_key = a[1]"."a[2]"."a[3]

                # Only ban the IP if its parent /24 wasn'"'"'t already banned
                # We check raw_subnet_counts vs hard limit here too to be safe
                if (subnet_counts[s_key] < t_3 && raw_subnet_counts[s_key] < hard_t_3) {
                    print "BAN_IP", ip, bad_ips[ip]
                }
            }
        }
    }' "$TMP.counts" > "$TMP.decisions"
    
    # 4. PROCESS DECISIONS
    while IFS="=" read -r type target count; do
        esc=\$(sed 's/\./\\\\./g' <<< "\$target")

        if [[ "\$type" == "BAN_3PART" ]]; then
            label="heavily_limited_range_\${target//./_}"
            entry="    ~^\${esc}\\\\.    \"\$label\";"
            
            # Check Parent /16
            parent="\${target%.*}"; parent_esc=\$(sed 's/\./\\\\./g' <<< "\$parent")
            if grep -qE "^[[:space:]]*~\^\${parent_esc}\\\\." "\$OUTPUT_FILE"; then continue; fi
            
            if ! grep -qF "\$entry" "\$OUTPUT_FILE"; then
                echo "\$entry" >> "\$OUTPUT_FILE"
                added_any=true
                timestamp "ADDED /24: \$target (\$count reqs)"
            fi

        elif [[ "\$type" == "BAN_2PART" ]]; then
            label="heavily_limited_range_\${target//./_}"
            entry="    ~^\${esc}\\\\.    \"\$label\";"
            if ! grep -qF "\$entry" "\$OUTPUT_FILE"; then
                echo "\$entry" >> "\$OUTPUT_FILE"
                added_any=true
                timestamp "ADDED /16: \$target (\$count reqs)"
            fi

        elif [[ "\$type" == "BAN_IP" ]]; then
            label="heavily_limited_ip_\${target//./_}"
            entry="    ~^\${esc}$    \"\$label\";"
            
            # Check Parents
            sub="\${target%.*}"; sub_esc=\$(sed 's/\./\\\\./g' <<< "\$sub")
            parent="\${target%.*.*}"; parent_esc=\$(sed 's/\./\\\\./g' <<< "\$parent")
            
            if grep -qE "^[[:space:]]*~\^\${sub_esc}\\\\." "\$OUTPUT_FILE" || \\
               grep -qE "^[[:space:]]*~\^\${parent_esc}\\\\." "\$OUTPUT_FILE"; then
               continue
            fi

            if ! grep -qF "\$entry" "\$OUTPUT_FILE"; then
                echo "\$entry" >> "\$OUTPUT_FILE"
                added_any=true
                timestamp "ADDED IP: \$target (\$count reqs)"
            fi
        fi
    done < "\$TMP.decisions"

done < "\$TMP"

if \$added_any; then
    if nginx -t > /dev/null 2>&1; then
        systemctl reload nginx
        timestamp "Nginx reloaded."
    else
        timestamp "Nginx test failed â€“ no reload."
    fi
fi
EOF

chmod +x "$INSTALL_DIR/save_offending_ips.sh"

# 7. Generate Initial Config Files
touch "$CONFIG_DIR/offending_ips.conf"

cat <<EOF > "$CONFIG_DIR/rate_limit_logic.conf"
# Maps the remote address to the limit key found in the offending list
map \$remote_addr \$heavily_limited_ip_limit_key {
    include $CONFIG_DIR/offending_ips.conf;
    default "";
}

# Define the rate limit zone
# 10r/m = 1 request per 6 seconds allowed on average
limit_req_zone \$heavily_limited_ip_limit_key zone=heavily_limited_ip_rate_limit:50m rate=10r/m;

# Custom error page for rate limiting
limit_req_status 429;
error_page 429 @ratelimit;
EOF

# 8. Setup Cron Job
echo "------------------------------------------------"
echo "Setting up Cron Job..."
echo "*/15 * * * * root $INSTALL_DIR/save_offending_ips.sh >> /var/log/abuse-shield.log 2>&1" > "$CRON_FILE"
chmod 644 "$CRON_FILE"
echo -e "${GREEN}Cron job installed to $CRON_FILE${NC}"

# 9. Output Instructions
echo "------------------------------------------------"
echo -e "${GREEN}INSTALLATION COMPLETE${NC}"
echo ""
echo "Please perform the following manual steps to activate the shield:"
echo ""
echo "1. Edit your Nginx configuration (e.g., nginx.conf or sites-available/default)."
echo "   Ensure you have the 'concise' log format defined:"
echo -e "   ${YELLOW}log_format concise '\$msec \$remote_addr \$is_bot \$host \$status';${NC}"
echo ""
echo "2. Add this line inside your 'http' block:"
echo -e "   ${YELLOW}include $CONFIG_DIR/rate_limit_logic.conf;${NC}"
echo ""
echo "3. Add these lines inside your 'server' blocks (specifically inside 'location /'):"
echo -e "   ${YELLOW}limit_req zone=heavily_limited_ip_rate_limit burst=2 nodelay;${NC}"
echo ""
echo "4. Add the error handler location block:"
echo -e "   ${YELLOW}location @ratelimit {"
echo -e "       return 429 \"Too Many Requests: Rate limit exceeded.\\n\";"
echo -e "   }${NC}"
echo ""
echo "5. Reload Nginx:"
echo "   nginx -t && systemctl reload nginx"
echo ""
echo "The script will now run every 15 minutes checking: $LOG_PATH"
